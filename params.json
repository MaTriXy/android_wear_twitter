{"name":"Android wear twitter","tagline":"Android wear twitter","body":"# Cliente de Twitter para android wear\r\n\r\n1. Motivación\r\n2. Estructura\r\n3. Aplicación del dispositivo\r\n4. Aplicación del wearable\r\n5. Librerías de terceros\r\n\r\n\r\n## 1. Motivación\r\n\r\nLa motivación de este proyecto era aprender yo mismo el funcionamiento de android wear: _customViews_, comunicaciones, etc...\r\n\r\nUn segundo objetivo y no menos importante es que sirva de proyecto para que otros puedan usarlo a modo de consulta para construir sus proyectos, pienso que resulta muy util un proyecto que implemente algo que te interese para que lo puedas consultar.\r\n\r\n## 2. Estructura\r\n\r\nUn proyecto de android wear, consta de dos módulos, uno es el proyecto que construirá la aplicación para el dispositivo, y el otro, para el wearable\r\n\r\n![](md_images/file_estructure.png)\r\n\r\nAmbos proyectos constan de sus propias actividades, recuros, manifest.xml etc... dos proyectos separados, una nota importante es que ambos proyectos han de tener el mismo nombre del paquete.\r\n\r\nEn tiempo de desarrollo, pudes probar las aplicaciones instalando directamente en el wearable o en el disposivo, pero al hacer la release, el apk sera del proyecto mobile, dentro de ella, se hallará una micro apk que se instalará automáticamente en el dispositivo wearable del usuario.\r\n\r\n\r\n## 3. Aplicación para el dispositivo\r\n\r\nUna aplicación normal android, con sus _activities_, _layouts_ básicamente, de cara al usuario se presenta un navegador para loguearse con twitter, si todo va bién se muestra una actividad con diciéndole que ya está conectado mostrándole su foto de perfil.\r\n\r\nLa parte interesante desde mi punto de vista es la comunicación con el wearable.\r\n\r\nEn todo momento el reloj podría pedir la lista de tweets, por lo que una parte de la aplicación siempre debería estar ejecutándose y poder encargarse de ello, para ello creo que un servicio es la mejor opción.\r\n\r\n```\r\n<service android:name=\".services.WearService\"/>\r\n```\r\n\r\nPor otro lado, el servicio debe iniciarse desde que se enciende el dispositivo, de otra forma el usuario tendría que abrir la aplicación despues de iniciarlo, no creo que sea la mejor opcion.\r\n\r\n```\r\n<uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" />\r\n```\r\n\r\nPara toda las conexiones con twitter me he basado en la librería **twitter4j**, una librería muy madura y completa para java encargada de toda la interacción con las APIs de twitter, unicamente crear la apllicación en twitter developers, seguir un poco la documentación y listo.\r\n\r\n### Comunicación con wearable\r\n\r\nY aquí la parte divertida, después de revisar la documentación de android developers la comunicación con el dispositivo wearable es casi trivial. Hay ciertos pasos que hay que respetar:\r\n\r\n1. Conectar gon _Google Play Services_\r\n\r\n```java\r\n@Override\r\npublic void onCreate() {\r\n   super.onCreate();\r\n\r\n   // Init & connect gApiClient\r\n   googleApiClient = new Builder(this)\r\n      .addConnectionCallbacks (gConnectionCallbacks)\r\n      .addOnConnectionFailedListener (gConnectionFailed)\r\n      .addApi(Wearable.API)\r\n      .build();\r\n\r\n   googleApiClient.connect();\r\n}\r\n```\r\n\r\n2. Esperar a que ```onConnected()``` sea llamado\r\n\r\n```java\r\nprivate final ConnectionCallbacks gConnectionCallbacks = new ConnectionCallbacks() {\r\n    @Override\r\n    public void onConnected(Bundle bundle) {\r\n\r\n       // Subscribe wear listeners\r\n       Wearable.MessageApi.addListener(googleApiClient, wearMessageListener);\r\n    }\r\n\r\n    @Override\r\n    public void onConnectionSuspended(int i) {\r\n\r\n        [...]\r\n    }\r\n};\r\n\r\n```\r\n\r\nEn este punto, el dispositivo está preparado para recibir mensajes mandados desde el dispositivos, en _android wear_, hay tres APIs de comunicación: ```MessageApi```, ```NodeApi```, ```DataApi```. \r\n\r\n\r\n\r\n\r\nEXPLICACIón MUY BREVE DE LAS APis\r\n### MessageApi\r\n\r\n\r\n\r\nLa primera comunicación con el wearable trata de averiguar si el servicio está corriendo, es algo parecido a:\r\n\r\n- ¿Hola, estás ahí?\r\n- Aqui estoy adelante\r\n\r\nEn el lenguaje de wear:\r\n\r\n- ```/tweets/state/hi/``` _(wearable)_\r\n- ```/tweets/state/how4u/``` _(device)_\r\n\r\nDespués de esto el _wearable_ ya sabe que hay el servicio esta disponible para poder pedir la lista de tweets del usuario. Para mandar mensajes, tanto en el _wearable_ como en el _device_ he usado la misma implementación de una _asynctask_\r\n\r\n\r\n```\r\nclass SendMessageTask extends AsyncTask <Void, Void, Void> {\r\n\r\n   private final String message;\r\n\r\n   SendMessageTask(String message) {\r\n      this.message = message;\r\n   }\r\n\r\n   @Override\r\n   protected Void doInBackground(Void... params) {\r\n       \r\n       // Such as /wear/message\r\n       String activityPath = message;\r\n\r\n       MessageApi.SendMessageResult result =  MessageApi.sendMessage(\r\n           googleApiClient, connectedNodes.get(0).getId(), \r\n           activityPath, null)\r\n           .await();\r\n    }\r\n\r\n    return null;\r\n    }\r\n}\r\n```\r\n\r\nComo se registro el listener para la api de mensajes en ```onConnected()``` también podemos recibir mensajes desde el wearable:\r\n\r\n```\r\nprivate final MessageApi.MessageListener wearMessageListener = new MessageApi.MessageListener() {\r\n    @Override\r\n    public void onMessageReceived(MessageEvent messageEvent) {\r\n\r\n        String msg = messageEvent.getPath();\r\n        Log.d(\"[DEBUG] WearService - onMessageReceived\", \"Message received: \" + msg);\r\n        \t\t\t\t\t\t\t\t\r\n        [...]\r\n    }\r\n}\r\n```\r\n\r\n### DataApi\r\n\r\nPara sincronizar datos, la mejor opción es la ```DataApi```, la que permite enviar tanto un ```payload``` serializando bytes como desees, o en forma de ```DataMaps```, envíando los datos como si de un ```Bundle``` se tratara.\r\n\r\nPara esta aplicación se ha utilizado ```DataMaps``` de esa forma, separando los datos por una cadena determinada, (quizás esta no sea la mejor opción) se consiguen enviar datos de una forma sencilla.\r\n\r\n,En este caso, se ha implementado una _asynctask_ para el envio del _timeline_, tras recibirlo con _twitter4j_ es mandado como un\t ```ArrayList<string>``` al wearable, se podría haber elegido otro modo, como serializar un _JSON_ y hacer el parser en el wearble, pero por rapidez se eligió ese.\r\n\r\n````\r\n\r\nclass SendTimeLineTask  extends AsyncTask<Void, Void, Void> {\r\n\r\n    private final ArrayList <String>  contents;\r\n\r\n    public SendTimeLineTask (Context c, ArrayList <String> contents) {\r\n        this.contents = contents;\r\n}\r\n\r\n    @Override\r\n    protected Void doInBackground(Void... nodes) {\r\n\r\n    PutDataMapRequest dataMap = PutDataMapRequest\r\n        .create (Constants.TIME_LINE_DATA);\r\n\r\n    dataMap.getDataMap().putStringArrayList(\"contents\", contents);\r\n\r\n    PutDataRequest request = dataMap.asPutDataRequest();\r\n\r\n    DataApi.DataItemResult dataItemResult = Wearable.DataApi\r\n        .putDataItem(googleApiClient, request)\r\n        .await();\r\n\r\n\r\n    return null;\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 4.Aplicación para el wearable\r\n\r\nUna aplicación para android wear se programa casi igual que una aplicación normal android, la aplicacion que se instala en el wearable tiene únicamente dos actividades:\r\n\r\n- ```WaitActivity``` - Actividad mostrada mientras el dispositivo hace la petición a twitter y envía los tweets al wearable\r\n\r\n- ```StreamActivity```- Actividad que mostrará el _timeline_ del usuario, también permite hacer _retweet_ o marcar como favorito un _tweet_ determinado\r\n\r\n#### WaitActivity\r\n\r\nEsta aplicación espera a que el dispositivo haga la petición mientras, por medio de una animación y una vista sencilla construye una especie de spinner y muestra un mensaje al usuario.\r\n\r\n\r\n![](https://3a3c2487a21adf7eab9f9e1c949cb1c6fbc1a71f.googledrive.com/host/0B62SZ3WRM2R2MldQdDNXVTk5bmc)\r\n\r\nEl efector del spinner es una simple imagen aplicada por una simple animación\r\n\r\n```\r\n<rotate\r\n\txmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n\tandroid:duration=\"1000\"\r\n\tandroid:repeatCount=\"infinite\"\r\n\tandroid:fromDegrees=\"0\"\r\n\tandroid:interpolator=\"@android:anim/anticipate_overshoot_interpolator\"\r\n\tandroid:pivotX=\"50%\"\r\n\tandroid:pivotY=\"50%\"\r\n\tandroid:toDegrees=\"359\" />\r\n```\r\n\r\nSi hubiera algún problema el mensaje de 'Loading...' cambiaría al error producido y el fondo mediante un ```<transition>``` se cambiaría a rojo.\r\n\r\n\r\n![](https://919c5da1a105a3a06e03fa4ec2c9901a70398228.googledrive.com/host/0B62SZ3WRM2R2TXNNWlJPREVXQTA)\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<transition xmlns:android=\"http://schemas.android.com/apk/res/android\">\r\n    <item android:drawable=\"@drawable/wait_idle\" />\r\n    <item android:drawable=\"@drawable/wait_error\" />\r\n</transition>\r\n```\r\n\r\n\r\nLa parte de comunicación con el dispositivo es como la explicada en la parte de la app del dispositivo, se etablece un protocolo de mensajes mediante la ```MessageApi```para finalmente ecuchar al método ```OnDataChanged()``` implementado por ```Wear.DataApi.Listener```, para recibir los tweets en forma de ``ÀrrayList<string>```, \r\n\r\nEl protocolo de  comunicación en cuanto al envío es el siguiente:\r\n\r\n**Para obtener el timeline:**\r\n\r\n\"/tweets/hi/\"\t\t\t\t\t_(Wearable)_\t_MessageApi_ \r\n\"/tweets/state/available\"\t\t_(Device)_ \t\t_MessageApi_\r\n\"/twitter/timeline\"\t\t\t\t_(Wearable)_ \t_MessageApi_\r\n\"/twitter/timeline\"\t\t\t\t_(Device)_ \t\t_DataApi_\r\n\r\n\r\n**Para hacer un retweet:**\r\n\r\n\"/tweets/retweet/\"\t\t\t\t\t_(Wearable)_\t_MessageApi_ \r\n\"/tweets/operation/ok\"\t\t\t\t_(Device)_ \t\t_MessageApi_\r\n\"/tweets/operation/fail\"\t\t\t\t_(Device)_ \t\t_MessageApi_\r\n\r\n\r\n**Para hacer un Favorito:**\r\n\r\n\"/tweets/favorite/\"\t\t\t\t\t_(Wearable)_\t_MessageApi_ \r\n\"/tweets/operation/ok\"\t\t\t\t_(Device)_ \t\t_MessageApi_\r\n\"/tweets/operation/fail\"\t\t\t_(Device)_ \t\t_MessageApi_\r\n\r\n\r\nEn cuanto llega el mensaje ```\"/tweets/operation/ok\"``` se abre una ```ConfirmationActivity``` produciendo el siguente efecto:\r\n\r\n\r\nIMAGEN\r\n\r\n```java\r\nIntent confirmationActivity = new Intent(getActivity(), ConfirmationActivity.class)\r\n\t.putExtra(ConfirmationActivity.EXTRA_ANIMATION_TYPE, ConfirmationActivity.SUCCESS_ANIMATION)\r\n\t.putExtra(ConfirmationActivity.EXTRA_MESSAGE, actionText.getText()+\"ed\");\r\n\r\nstartActivity(confirmationActivity);\r\n\r\n```\r\n\r\nEs un poco raro el hecho de declarar dicha actividad en el ```Manifest.xml```\r\n\r\n```\r\n...\r\n<activity android:name=\"android.support.wearable.activity.ConfirmationActivity\"/>\r\n...\r\n```\r\n\r\nThe layout\r\n\r\nDespues de pasar 'WaitActivity', se pasa a StreamActivity, esta permite, consultar los tweets del usuario, hacer retweet y marcarlos como favoritos\r\n\r\n** __NOTE__ Hay un error conocido conforme a veces se producen errores al hacer retweet después de usar la aplicación varias veces, esto es debido a las keys de twitter, se solucionará en próximos commits\r\n\r\nEl layout de StreamActivity es el siguiente:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n\r\n<LinearLayout\r\n\txmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n\tandroid:layout_width=\"match_parent\"\r\n\tandroid:layout_height=\"match_parent\"\r\n\tandroid:orientation=\"vertical\"\r\n\tandroid:background=\"@drawable/tw_wall\"\r\n\t>\r\n\r\n\t<android.support.wearable.view.GridViewPager\r\n\tandroid:id=\"@+id/stream_pager\"\r\n\tandroid:layout_width=\"match_parent\"\r\n\tandroid:layout_height=\"match_parent\"\r\n\tandroid:keepScreenOn=\"true\"\r\n\t/>\r\n</LinearLayout>\r\n\r\n```\r\n\r\nEl GridViewPager, es lo único hay que tener en cuenta, con un simple adaptador podemos asignar un scroll horizontal para cambiar entre fragments de acciones\r\n\r\n```java\r\n...\r\nstreamPager = (GridViewPager) findViewById(R.id.stream_pager);\r\n\r\nstreamPager.setAdapter(new TwitterAdapter (StreamActivity.this,\r\n    getFragmentManager(), visibleTweets));\r\n...\r\n\r\n\r\nclass TwitterAdapter extends FragmentGridPagerAdapter {\r\n\tprivate Context context;\r\n\tprivate ArrayList<Tweet> tweets;\r\n\r\n\tpublic TwitterAdapter(Context context, FragmentManager fm, ArrayList<Tweet> tweets) {\r\n\t\tsuper(fm);\r\n\r\n\t\tthis.tweets = tweets;\r\n\t\tthis.context = context;\r\n\t}\r\n\r\n\r\n\t@Override\r\n\tpublic Fragment getFragment(int row, int column) {\r\n\t\tTweet currentTweet = tweets.get(row);\r\n\t\tTwitterActionFragment twitterActionFragment = new TwitterActionFragment();\r\n\r\n\t\tif (column == 0) {\r\n\t\t\tTweetFragment tf = new TweetFragment();\r\n\t\t\ttf.setCardTweet(currentTweet);\r\n\t\t\treturn tf;\r\n\r\n\t\t} else if (column == 1) {\r\n\t\t\ttwitterActionFragment.setTwAction(TwitterAction.RETWEET);\r\n\r\n\t\t} else if (column == 2) {\r\n\t\t\ttwitterActionFragment.setTwAction(TwitterAction.FAVORITE);\r\n\t\t}\r\n\r\n\t\ttwitterActionFragment.setCurrentTweet(currentTweet);\r\n\t\treturn twitterActionFragment;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int getRowCount() {\r\n\t\treturn tweets.size();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int getColumnCount(int row) {\r\n\treturn 3;\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}