{"name":"Android wear twitter","tagline":"","body":"# Twitter client for android wear\r\n\r\n## 1. Motivation\r\n\r\nThe motivation of this project was to learn how the android wear framework works, using theirs views, communication APIs, etc...\r\n\r\nA second objective was to share it as a reference project, so others can use it, modify it or make what they want with it. \r\n\r\nI think that is very useful to learn by example, so I really aprecciate projects like this.\r\n\r\n## 2. Project structure\r\n\r\nIf you create a project with android wear and android studio, you will be se two main modules: __wear__ and __mobile__.\r\n\r\nWhen you make an android wear _release_, you get a single _.apk_, which will be downloaded from google play by your users, when one of them install that _.apk_ on his phone, another app will be installed automatically on his wearable. That's because the release _apk's_ with android wear, has an 'micro-apk' inside them.\r\n\r\nThat _micro-apk_ is built by the __wear__ module, and the app that is installed on their phone consists on the __mobile__ module.\r\n\r\n![](https://87ccd03f34f5850e9f58050faacff843fdb2a928.googledrive.com/host/0B62SZ3WRM2R2TDVIN2ptNGVndE0)\r\n\r\nAt develop time, you can compile your __wear__ module directly on your wear device or emulator.\r\n\r\n## 3. Handheld app\r\n\r\nLike a normal android app, has an _activity_, a few _fragments_ and some layouts, the user, when press the _login_ button, will see a browser with the twitter login, if everything goes well the main fragment will change and the user will see their twitter profile photo, username, and the background will turn to their twitter profile background.\r\n\r\n![](https://cef58420144e1df00f893fa4436747dce6972cb0.googledrive.com/host/0B62SZ3WRM2R2V0Y2MlpwR3lEcUU)\r\n\r\nThe interesting part from my point of view is the communication with the wearable. \r\n\r\nThe clock awalys could ask the list of tweets, so the class that asks twitter for the tweets must always be available and able to take care of it, so I think that a service is the best choice.\r\n\r\n```\r\n<service android:name=\".services.WearService\"/>\r\n```\r\n\r\nThat service must be started when the device boots, otherwise the user would have to open the application after start manually, I do not think it's the best option, I can reach that with a broadcast receiver\r\n\r\n```\r\n<receiver android:name=\".receivers.BootReceiver\" android:enabled=\"true\" android:exported=\"false\">\r\n  <intent-filter>\r\n    <action android:name=\"android.intent.action.BOOT_COMPLETED\"/>\r\n  </intent-filter>\r\n</receiver>\r\n```\r\n\r\nFor all twitter connections I had relied in the library [twitter4j](http://twitter4j.org/en/index.html), a very mature and complete java library responsible for all interaction with twitter APIs, you only have to create an app in twitter developers, __twitter4j__ will do the hard work.\r\n\r\n### Wearable comunication\r\n\r\nAnd here's the fun part, after reviewing the documentation developers android communication with the wearable device is almost trivial. There are certain steps that must be respected:\r\n\r\n1. Connect with **Google Play Services**\r\n\r\n```java\r\n@Override\r\npublic void onCreate() {\r\n   super.onCreate();\r\n\r\n   // Init & connect gApiClient\r\n   googleApiClient = new Builder(this)\r\n      .addConnectionCallbacks (gConnectionCallbacks)\r\n      .addOnConnectionFailedListener (gConnectionFailed)\r\n      .addApi(Wearable.API)\r\n      .build();\r\n}\r\n```\r\n\r\n2. Call ```.connect()``` method\r\n\r\n```java\r\n   googleApiClient.connect();\r\n```\r\n\r\n2. Wait ```onConnected()``` to be called\r\n\r\n```java\r\nprivate final ConnectionCallbacks gConnectionCallbacks = new ConnectionCallbacks() {\r\n    @Override\r\n    public void onConnected(Bundle bundle) {\r\n\r\n       // Subscribe wear listeners\r\n       Wearable.MessageApi.addListener(googleApiClient, wearMessageListener);\r\n    }\r\n\r\n    @Override\r\n    public void onConnectionSuspended(int i) {\r\n\r\n        [...]\r\n    }\r\n};\r\n\r\n```\r\nAt this point, the device is ready to communicate with android wear devices if all went well, otherwhise the ```onConnectionFailedListener``` would be fired.\r\n\r\nNow we can use the communicate APIs that google provide us, there is 3 APIs to communicate to communicate with the wearable: ```MessageApi```, ```NodeApi```, ```DataApi```.\r\n\r\n### MessageApi\r\n\r\n\r\nLa primera comunicación con el wearable trata de averiguar si el servicio está corriendo, es algo parecido a:\r\n\r\n_¿Hola, estás ahí?  _\r\n_Aqui estoy, adelante _<br>\r\n\r\nEn el lenguaje de wear:\r\n\r\n```/tweets/state/hi/``` _(wearable)_ \r\n```/tweets/state/how4u/``` _(device)_ <br>\r\n\r\nDespués de esto el _wearable_ ya sabe que hay el servicio esta disponible para poder pedir la lista de tweets del usuario. Para mandar mensajes, tanto en el _wearable_ como en el _device_ he usado la misma implementación de una _asynctask_\r\n\r\n\r\n```\r\nclass SendMessageTask extends AsyncTask <Void, Void, Void> {\r\n\r\n   private final String message;\r\n\r\n   SendMessageTask(String message) {\r\n      this.message = message;\r\n   }\r\n\r\n   @Override\r\n   protected Void doInBackground(Void... params) {\r\n       \r\n       // Such as /wear/message\r\n       String activityPath = message;\r\n\r\n       MessageApi.SendMessageResult result =  MessageApi.sendMessage(\r\n           googleApiClient, connectedNodes.get(0).getId(), \r\n           activityPath, null)\r\n           .await();\r\n    }\r\n\r\n    return null;\r\n    }\r\n}\r\n```\r\n\r\nAfter call to ```googleApiClient()```and wait to ```onConnected()``` were called, we registered to receive message events using the ```Wear.MessageListener.addListener(myListener)``` method, so we are able to manage the messages with this method\r\n\r\n```\r\nprivate final MessageApi.MessageListener wearMessageListener = new MessageApi.MessageListener() {\r\n    @Override\r\n    public void onMessageReceived(MessageEvent messageEvent) {\r\n\r\n        String msg = messageEvent.getPath();\r\n        Log.d(\"[DEBUG] WearService - onMessageReceived\", \"Message received: \" + msg);\r\n        \t\t\t\t\t\t\t\t\r\n        [...]\r\n    }\r\n}\r\n```\r\n\r\n### DataApi\r\n\r\nThe DataApi allows you to synchronice data between handhelf and wearables, a message in the Data Api consists of a __Payload__, to send whatever data you wish, ad __Path__, a unique string starting with a forward slash.\r\n\r\nInstead to send a byte array you can use ```DataMaps```, are used as android bundles inside the DataApi\r\n\r\nTo send & receive the tweets from the handfeld to the wear device, y used DataMaps with strings composed by fields separed by a pattern (Maybe this is not the best option).\r\n\r\nIn this case, I have implemented an _asynctask_ for send the twitter timeline after receiving with _twitter4_. The timelien is sent as a ```ArrayList<String>```\r\n\r\n````\r\n\r\nclass SendTimeLineTask  extends AsyncTask<Void, Void, Void> {\r\n\r\n    private final ArrayList <String>  contents;\r\n\r\n    public SendTimeLineTask (Context c, ArrayList <String> contents) {\r\n        this.contents = contents;\r\n}\r\n\r\n    @Override\r\n    protected Void doInBackground(Void... nodes) {\r\n\r\n    PutDataMapRequest dataMap = PutDataMapRequest\r\n        .create (Constants.TIME_LINE_DATA);\r\n\r\n    dataMap.getDataMap().putStringArrayList(\"contents\", contents);\r\n\r\n    PutDataRequest request = dataMap.asPutDataRequest();\r\n\r\n    DataApi.DataItemResult dataItemResult = Wearable.DataApi\r\n        .putDataItem(googleApiClient, request)\r\n        .await();\r\n\r\n\r\n    return null;\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 4.Wearable app\r\n\r\n![](https://219ede0846187d7fd9922311fa441d9820915b2c.googledrive.com/host/0B62SZ3WRM2R2bHhlVExmakJEaFU)\r\n\r\nAn application for android wear is programmed like a normal android app, with a few differences, you can't all the android APIs that you normally use in a common android app such as ```android.net```. Also,  you have to notice that the user experience is a little bit difference than a normal Android app.\r\n\r\nThe wear app, is composed by the following activities:\r\n\r\n- ```WaitActivity``` - An activity shown meanwhile the handfeld app is requesting the user timeline. In backwards this activity makes a hard work of communication with the handfeld app.\r\n\r\n- ```StreamActivity```- An activity that shows the user _timeline_, also allows to _retweet_ a tweet or flag as favorited.\r\n\r\n#### WaitActivity\r\n\r\nThe effect of the 'spinner' is a simple ImageView, with the following animation applied\r\n\r\n![](https://3a3c2487a21adf7eab9f9e1c949cb1c6fbc1a71f.googledrive.com/host/0B62SZ3WRM2R2MldQdDNXVTk5bmc)\r\n  \r\n\r\n```xml\r\n<rotate\r\n\txmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n\tandroid:duration=\"1000\"\r\n\tandroid:repeatCount=\"infinite\"\r\n\tandroid:fromDegrees=\"0\"\r\n\tandroid:interpolator=\"@android:anim/anticipate_overshoot_interpolator\"\r\n\tandroid:pivotX=\"50%\"\r\n\tandroid:pivotY=\"50%\"\r\n\tandroid:toDegrees=\"359\" />\r\n```\r\n\r\n```java\r\n  loadingSegment = (ImageView) findViewById(R.id.loading_segment);\r\n  loadingSegment.startAnimation(AnimationUtils.loadAnimation(this, R.anim.loading_animation));\r\n\r\n```\r\n\r\nIf there is any problem the 'Loading...' message will turn to show the error and the background, produced by a ```<transition>```\r\n\r\n![](https://919c5da1a105a3a06e03fa4ec2c9901a70398228.googledrive.com/host/0B62SZ3WRM2R2TXNNWlJPREVXQTA)\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<transition xmlns:android=\"http://schemas.android.com/apk/res/android\">\r\n    <item android:drawable=\"@drawable/wait_idle\" />\r\n    <item android:drawable=\"@drawable/wait_error\" />\r\n</transition>\r\n```\r\n\r\n```\r\n<FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    ...\r\n    android:background=\"@drawable/tr_error\"\r\n    ...\r\n    >\r\n</FrameLayout>    \r\n```\r\n\r\n\r\nA protocol of messages is established to perform the communication, first of all, in the ```WaitActivity``` a message task is sent with the messaje 'available', after 3 seconds if the handfeld app doesn't responds, it means that there is a problem with the service, so show the proper message to the user. \r\n\r\nIf the handfeld app responds successfully the wearable will sent another message taks to tell the handfeld app that has to start to request the user tweets, when the request is done, the handfeld app will sent a DataTask with a list of tweets\r\n\r\nThe wear message listener...\r\n\r\n```\r\n  @Override\r\n    public void onMessageReceived(MessageEvent messageEvent) {\r\n\r\n        String messagePath = messageEvent.getPath();\r\n\r\n        if (messagePath.equals(\"/tweets/operation/ok\")) {\r\n            onRetweetListener.onActionOK();\r\n        }\r\n\r\n        if (messagePath.equals(\"/tweets/operation/fail\")) {\r\n            onRetweetListener.onActionFail();\r\n        }\r\n\r\n        if (messagePath.equals(\"/tweets/state/no_internet\")) {\r\n            deviceListener.onProblem(messagePath);\r\n        }\r\n\r\n        if (messagePath.equals(\"/tweets/state/available\")) {\r\n            isTwitterServiceIsRunning = true;\r\n        }\r\n    }\r\n``` \r\n  \r\nThe tweets message listener (DataListener):\r\n\r\n```\r\n    @Override\r\n    public void onDataChanged(DataEventBuffer dataEvents) {\r\n\r\n        for (DataEvent event: dataEvents) {\r\n\r\n            String eventUri = event.getDataItem().getUri().toString();\r\n\r\n            if (eventUri.contains (\"/twitter/timeline\")) {\r\n\r\n                DataMapItem dataItem = DataMapItem.fromDataItem (event.getDataItem());\r\n                ArrayList <String> tweets = dataItem.getDataMap().getStringArrayList(\"contents\");\r\n                deviceListener.onTimeLimeReceived(tweets);\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n####  Protocol:\r\n\r\n**To get the timeline in the wearable:**\r\n\r\n\"/tweets/hi/\"\t\t\t\t\t_(Wearable)_\t_MessageApi_ \r\n\"/tweets/state/available\"\t\t_(Device)_ \t\t_MessageApi_\r\n\"/twitter/timeline\"\t\t\t\t_(Wearable)_ \t_MessageApi_\r\n\"/twitter/timeline\"\t\t\t\t_(Device)_ \t\t_DataApi_\r\n\r\n\r\n**Retweet a tweet:**\r\n\r\n\"/tweets/retweet/\"\t\t\t\t\t_(Wearable)_\t_MessageApi_ \r\n\"/tweets/operation/ok\"\t\t\t\t_(Device)_ \t\t_MessageApi_\r\n\"/tweets/operation/fail\"\t\t\t\t_(Device)_ \t\t_MessageApi_\r\n\r\n\r\n**Flag a tweet as favorite:**\r\n\r\n\"/tweets/favorite/\"\t\t\t\t\t_(Wearable)_\t_MessageApi_ \r\n\"/tweets/operation/ok\"\t\t\t\t_(Device)_ \t\t_MessageApi_\r\n\"/tweets/operation/fail\"\t\t\t_(Device)_ \t\t_MessageApi_\r\n\r\n\r\n## StreamActivity\r\n\r\nAfter _'WaitActivity'_ do the hard work, the _'StreamActivity'_ will be shown, this one will show a ```GridViewPager```, that view will allow to scroll down seeing the available tweets, scrolling right the user will be able to rewtweet a tweet o flag one as favorite.\r\n\r\nThe ```GridViewPager``` works with a ```FragmentGridAdapter```, that works like the common adapters used in ```ListViews```, ```GridViews```, etc...\r\n\r\n```java\r\n        ...\r\n        streamPager = (GridViewPager) findViewById(R.id.stream_pager);\r\n\r\n        streamPager.setAdapter(new TwitterAdapter (StreamActivity.this,\r\n                getFragmentManager(), visibleTweets));\r\n                \r\n        ...\r\n```\r\n```java\r\n    class TwitterAdapter extends FragmentGridPagerAdapter {\r\n        private Context context;\r\n        private ArrayList<Tweet> tweets;\r\n\r\n        public TwitterAdapter(Context context, FragmentManager fm, ArrayList<Tweet> tweets) {\r\n            super(fm);\r\n\r\n            this.tweets = tweets;\r\n            this.context = context;\r\n        }\r\n        \r\n        @Override\r\n        public Fragment getFragment(int row, int column) {\r\n            Tweet currentTweet = tweets.get(row);\r\n            TwitterActionFragment twitterActionFragment = new TwitterActionFragment();\r\n\r\n            if (column == 0) {\r\n                TweetFragment tf = new TweetFragment();\r\n                tf.setCardTweet(currentTweet);\r\n                return tf;\r\n\r\n            } else if (column == 1) {\r\n                twitterActionFragment.setTwAction(TwitterAction.RETWEET);\r\n\r\n            } else if (column == 2) {\r\n                twitterActionFragment.setTwAction(TwitterAction.FAVORITE);\r\n            }\r\n\r\n            twitterActionFragment.setCurrentTweet(currentTweet);\r\n            return twitterActionFragment;\r\n        }\r\n\r\n        @Override\r\n        public int getRowCount() {\r\n            return tweets.size();\r\n        }\r\n\r\n        @Override\r\n        public int getColumnCount(int row) {\r\n            return 3;\r\n        }\r\n    }\r\n```\r\n\r\nAnd the layout\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n\r\n<LinearLayout\r\n\txmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n\tandroid:layout_width=\"match_parent\"\r\n\tandroid:layout_height=\"match_parent\"\r\n\tandroid:orientation=\"vertical\"\r\n\tandroid:background=\"@drawable/tw_wall\"\r\n\t>\r\n\r\n\t<android.support.wearable.view.GridViewPager\r\n\tandroid:id=\"@+id/stream_pager\"\r\n\tandroid:layout_width=\"match_parent\"\r\n\tandroid:layout_height=\"match_parent\"\r\n\tandroid:keepScreenOn=\"true\"\r\n\t/>\r\n</LinearLayout>\r\n\r\n__NOTE__ _There is a known bug , sometimes the handfeld service is not retweeting and marking a tweet as favorite well, that's because the twitter keys expires. Will be fixed soon_","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}